#!/vendor/bin/sh
#
# Copyright (c) 2017 - 2021 Amazon.com, Inc. or its affiliates.  All rights reserved.
# PROPRIETARY/CONFIDENTIAL.  USE IS SUBJECT TO LICENSE TERMS.
#
# Common utility functions for wifi scripts
#

#
# Externally accessible global variables should be prefixed with CMN_
#

# Default values
CMN_LOG_TAG="${0##*/}: $1"                              # NOTE: should be overridden by including script
CMN_WIF='wlan0'
CMN_UIF=''
CMN_UIF24='wlan0'
CMN_UIF50='wlan1'
CMN_DIF24='wl0.1'
CMN_DIF50='wl1.1'
CMN_DISABLE24='0'
CMN_DISABLE50='0'
CMN_HIF='ap0'                                           # host AP interface name
readonly CMN_RESOLV_FILE="/data/misc/dhcp/resolv.conf"  # WARNING: Must match: init.wifi.rc, firewall.sh

DBG='0'
ROOT='0'
WIFI_VERBOSE='0'
FOSFLAGS_VERBOSE='0'
BOOT_DONE='0'
UIF=''

# Commands from /vendor/bin/
IFCONFIG=/vendor/bin/ifconfig
GETPROP=/system/bin/getprop
SETPROP=/system/bin/setprop
ECHO=/vendor/bin/echo
LOG=/vendor/bin/log
LS=/vendor/bin/ls
MV=/vendor/bin/mv
CHOWN=/vendor/bin/chown
CHMOD=/vendor/bin/chmod
CAT=/vendor/bin/cat
WC=/vendor/bin/wc
TAIL=/vendor/bin/tail
TOUCH=/vendor/bin/touch
IP=/vendor/bin/ip

# WARNING: Must match the method code generated by IWifiManager.aidl for TRANSACTION_setWifiEnabled
WIFI_ENABLE_CODE=24

# System properties
DBG_PROP='ro.debuggable'                                # get debuggable state
WIF_PROP='wifi.interface'                               # get Android wifi interface name
UIF24_PROP='wifi.ro.24.if'                              # get upstream interface (2.4 GHz)
UIF50_PROP='wifi.ro.50.if'                              # get upstream interface (5.0 GHz)
UIF_PROP='wifi.ro.uif'                                  # record the upstream interface
DIF24_PROP='wifi.ro.softap.24.if'                       # get downstream interface (2.4 GHz)
DIF50_PROP='wifi.ro.softap.50.if'                       # get downstream interface (5.0 GHz)
DISABLE_SAP_PROP='persist.wifi.auto_softaps_off'        # controls auto softAP (both) start / stop (debug)
DISABLE_SAP_CTRL_PROP='persist.wifi.auto_softaps_ctrl'  # controls auto softAP start / stop (debug)
                                                        # 0=both on, 1=2.4 only off, 2=5.0 only off, 3=both off
BOOT_DONE_PROP='sys.boot_completed'                     # get boot completed state
FOSFLAGS_VERBOSE_PROP='sys.init_log_level'              # get fos_flags verbose level
WIFI_VERBOSE_PROP='debug.wifi_verbose_logging_enb'      # get wifi verbose logging state

# Log output
#  usage: ilog log_message
#
# Uses global $CMN_LOG_TAG defined in calling script
ilog()
{
    $ECHO "$1"
    $LOG -p i -t "$CMN_LOG_TAG" "$1"
}

dlog()
{
    if ! is_debuggable; then
        return
    fi

    $ECHO "$1"
    $LOG -p d -t "$CMN_LOG_TAG" "$1"
}

elog()
{
    $ECHO "$1"
    $LOG -p e -t "$CMN_LOG_TAG" "$1"
}

# Get property values
#  usage: get_prop property VAR
get_prop()
{
    local tmp=`$GETPROP "$1"`
    if [[ -n "$tmp" ]]; then
        eval $2="'$tmp'"
    fi
}

# Clear property values
#  usage: clear_prop property
clear_prop()
{
    local tmp=`$GETPROP "$1"`
    if [[ -n "$tmp" ]]; then
        $SETPROP $1 ''
    fi
}

# Limit log buffer size
#  usage: limit_log_buffer log_file
#
# Needs CMN_DBG and CMN_ROOT to be defined
limit_log_buffer()
{
    local log_file=$1
    local max_lines=500

    if [[ -e "$log_file" ]]; then
        wc_array=( `$WC -l "$log_file"` )
        local lines=${wc_array[0]}
        if (( $lines > $max_lines )); then
            $ECHO -e "*** $log_file limit ($max_lines) reached - truncated ***\n" > ${log_file}_tmp
            $TAIL -n "$max_lines" "$log_file" >> ${log_file}_tmp
            $MV ${log_file}_tmp "$log_file"
            $CHOWN wifi:wifi "$log_file"
            $CHMOD 660 "$log_file"
        fi
    elif is_debuggable; then
        $TOUCH "$log_file"
        $CHOWN wifi:wifi "$log_file"
        $CHMOD 660 "$log_file"
    fi
}

# Determine if wifi is enabled
#  usage: is_wifi_enabled ignore_uif [log_state]
is_wifi_enabled()
{
    local ignore_uif=$1
    local log_state=$2

    # Check status of supplicant and Android wifi interface
    local wpa_up=`$LS /dev/socket/wpa_wlan0 2>/dev/null`
    local uif_up=`$IFCONFIG | grep $CMN_WIF 2>/dev/null`
    if [[ -z "$wpa_up" ]] || [[ $ignore_uif == '0' && -z "$uif_up" ]]; then
        if [[ -n "$log_state" ]]; then
            if [[ "$ignore_uif" == '1' ]]; then
                dlog "wifi state (wpa='$wpa_up')"
            else
                dlog "wifi state (wpa='$wpa_up' : uif='$uif_up')"
            fi
        fi
        return 1
    fi

    return 0
}

# Determine if wifi is disabled
#  usage: is_wifi_disabled ignore_uif [log_state]
is_wifi_disabled()
{
    local ignore_uif=$1
    local log_state=$2

    # Check status of supplicant and Android wifi interface
    local wpa_up=`$LS /dev/socket/wpa_wlan0 2>/dev/null`
    local uif_up=`$IFCONFIG | grep $CMN_WIF 2>/dev/null`
    if [[ -n "$wpa_up" ]] || [[ $ignore_uif == '0' && -n "$uif_up" ]]; then
        if [[ -n "$log_state" ]]; then
            if [[ "$ignore_uif" == '1' ]]; then
                dlog "wifi state (wpa='$wpa_up')"
            else
                dlog "wifi state (wpa='$wpa_up' : uif='$uif_up')"
            fi
        fi
        return 1
    fi

    return 0
}

# Enable wifi
#  usage: enable_wifi
enable_wifi()
{
    dlog "enable (re-enable) wifi"
    service call wifi "$WIFI_ENABLE_CODE" s16 "${0##*/}" i32 1 >/dev/null
}

# Disable wifi
#  usage: disable_wifi
disable_wifi()
{
    dlog "disable wifi"
    service call wifi "$WIFI_ENABLE_CODE" s16 "${0##*/}" i32 0 >/dev/null
}

# Ensure wifi is enabled
#  usage: ensure_wifi_enabled tsecs [ignore_uif]
ensure_wifi_enabled()
{
    if [[ -z "$1" ]]; then
        elog "ensure_wifi_disable: no timeout provided"
        return 1
    fi

    local timeout=$(( $1 * 4 )) # convert secs to quarter seconds
    local ignore_uif=$2
    if [[ -z "$ignore_uif" ]]; then
        ignore_uif=0
    fi

    # Ensure wifi is enabled - enable if needed
    #  - supplicant(s) and main radio will be restarted automatically
    #  - If Android / zygote is not running (boot not done), the caller was the init process and
    #  wifi should not be re-enabled.
    dlog "ensure wifi enabled"
    if [[ "$BOOT_DONE" == '1' ]] && ! ( is_wifi_enabled $ignore_uif ) ; then
        dlog "enabling (re-enabling) wifi"
        enable_wifi

        # Check if wifi is enabled
        local c=1
        while (( $c <= $timeout ))
        do
            if ( is_wifi_enabled $ignore_uif) ; then
                break
            fi
            sleep 0.25
            (( c++ ))
        done
        if ! ( is_wifi_enabled $ignore_uif 1 ) ; then
            return 1
        fi
        dlog "wifi enabled"
    fi

    return 0
}

# Ensure wifi is disabled
#  usage: ensure_wifi_disabled tsecs [ignore_uif]
ensure_wifi_disabled()
{
    if [[ -z "$1" ]]; then
        elog "ensure_wifi_disable: no timeout provided"
        return 1
    fi

    local timeout=$(( $1 * 4 )) # convert secs to quarter seconds
    local ignore_uif=$2
    if [[ -z "$ignore_uif" ]]; then
        ignore_uif=0
    fi

    # Ensure wifi is disabled - disable if needed
    #  - supplicant(s) and main radio will be brought down
    dlog "ensure wifi disabled"
    if [[ "$BOOT_DONE" == '1' ]] && ! ( is_wifi_disabled $ignore_uif ) ; then
        dlog "temporarily disabling wifi"
        disable_wifi

        # Check if wifi is disabled
        local c=1
        while (( $c <= $timeout ))
        do
            if ( is_wifi_disabled $ignore_uif ) ; then
                break
            fi
            sleep 0.25
            (( c++ ))
        done
        if ! ( is_wifi_disabled $ignore_uif 1 ) ; then
            return 1
        fi
        dlog "wifi disabled"
    fi

    return 0
}

# Determine if pid is active
#  usage: is_pid_active pid name
#  0 - active, 1 - inactive
is_pid_active()
{
    local pid=$1
    local name=$2
    local name_len=${#name}

    # Check status of pid using proc entry cmdline
    if [[ -n "$pid" && -n "$name" ]]; then
        local cmdline=`$CAT /proc/$pid/cmdline 2>/dev/null`
        if [[ -n "$cmdline" && "$name" == "${cmdline:0:$name_len}" ]]; then
            return 0
        fi
    fi

    return 1
}

# Determin host AP interface status
#  usage: is_hostAP_interface_up [hostAP interface name]
# Returns 0 if true, 1 if false
is_hostAP_interface_up()
{
    local IF="$1"
    local cmd=`$IFCONFIG $IF 2>/dev/null`
    if [[ -n "$cmd" ]]; then
        return 0
    fi

    return 1
}

# Delete the virtual interface by finding its MAC address
#  usage: delete_virt_iface dif
delete_virt_iface()
{
    local dif=$1
    local cur_ether_addr perm_ether_addr uif
    local bss=`wl -i "$dif" bss 2>/dev/null`

    # Check if interface exists
    if [[ -z "$bss" ]]; then
        dlog "interface $dif not available for removal"
        return 0
    fi

    # Ensure interface is down before trying to remove it
    if [[ "$bss" == "up" ]]; then
        wl -i "$dif" bss down

        # Check if interface is down
        # - allow up to 5 seconds for transition
        local c=1
        while (( $c <= 20 ))
        do
            bss=`wl -i "$dif" bss 2>/dev/null`
            if [[ "$bss" == "down" ]]; then
                break
            fi
            sleep 0.25
            (( c++ ))
        done
        if [[ "$bss" == "up" ]]; then
            elog "interface is not down ($dif=$bss) - cannot remove"
            return 1
        fi
    fi

    dlog "removing interface $dif"

    $IFCONFIG "$dif" 0.0.0.0 down
    perm_ether_addr=$(wl -i "$dif" perm_etheraddr) && \
    perm_ether_addr=$(cut -d' ' -f2 <<< "$perm_ether_addr") && \
    cur_ether_addr=$(wl -i "$dif" cur_etheraddr) && \
    cur_ether_addr=$(cut -d' ' -f2 <<< "$cur_ether_addr") && \
    uif=$($IFCONFIG -a | grep -i "$perm_ether_addr") && \
    uif=$(cut -d' ' -f1 <<< "$uif") && \
    wl -i "$uif" p2p_ifdel "$cur_ether_addr"

    return 0
}

# Determine soft APs status
#  usage: are_softAPs_up [log_state]
# Returns 0 if true, > 0 if false and > 1 if false and in a different state
are_softAPs_up()
{
    local log_state=$1

    local bss24=`wl -i "$CMN_DIF24" bss 2>/dev/null`
    local bss50=`wl -i "$CMN_DIF50" bss 2>/dev/null`
    if [[ "$CMN_DISABLE24" != '1' && "$CMN_DISABLE50" != '1' && "$bss24" != "$bss50" ]] \
        || [[ "$CMN_DISABLE24" == '1' && -n "$bss24" ]] \
        || [[ "$CMN_DISABLE50" == '1' && -n "$bss50" ]]; then
        elog "soft APs not in expected state ($CMN_DIF24='$bss24', $CMN_DIF50='$bss50')"
        return 2
    elif [[ "$CMN_DISABLE24" != '1' && "$bss24" != "up" ]] || [[ "$CMN_DISABLE50" != '1' && "$bss50" != "up" ]]; then
        if [[ -n "$log_state" ]]; then
            ilog "soft AP(s) not available ($CMN_DIF24='$bss24', $CMN_DIF50='$bss50')"
        fi
        return 1
    fi

    return 0
}

# Determine whether device is in a debuggable state
# - based on build type, root access and verbose logging
is_debuggable()
{
    if [[ "$DBG" == '1' || "$ROOT" == '1' || "$WIFI_VERBOSE" != '0' || "$FOSFLAGS_VERBOSE" == '7' ]]; then
        return 0
    fi

    return 1
}

# Get upstream network interface from 'ip route'
get_upstream_iface()
{
    # Find upstream interface dynamically
    inet_array=( `$IP route get 1.1.1.1 2>/dev/null` )
    UIF=${inet_array[4]}
}

# Update upstream network interface from 'ip route'
#  usage: update_upstream_iface [tsecs]
update_upstream_iface()
{
    local timeout=$1

    if [[ -z $timeout ]]; then
        timeout=0
    fi
    timeout=$(( $timeout * 4 )) # convert secs to quarter seconds

    # Get upstream network interface from 'ip route'
    # - requires that IP address has been assigned (usually from DHCP)
    # - optional timeout allows for repeated queries to allow DHCP lease to be confirmed
    get_upstream_iface
    if [[ -z $UIF ]] && [[ $timeout -gt 0 ]]; then
        local c=1
        while (( $c <= $timeout ))
        do
            get_upstream_iface
            if [[ -n $UIF ]]; then
                break
            fi
            sleep 0.25
            (( c++ ))
        done
    fi

    # Default to wlan0 if no active upstream interface found
    # - primarily used for the OOBE use cases when no network has been established without Ethernet
    if [[ -z $UIF ]]; then
        ilog "NOTE: no active upstream interface found; default is wlan0"
        UIF="wlan0"
    fi
    CMN_UIF=$UIF
    $SETPROP $UIF_PROP $CMN_UIF
    dlog "NOTE: upstream interface is $CMN_UIF prop $UIF_PROP"
}

# Dumps common configuration parameters
dump_cmn_cfg()
{
    if is_debuggable; then
        $ECHO "$DIF24_PROP = $CMN_DIF24"
        $ECHO "$DIF50_PROP = $CMN_DIF50"
        $ECHO "$DISABLE_SAP_PROP | $DISABLE_SAP_CTRL_PROP = $CMN_DISABLE24 : $CMN_DISABLE50"
    fi
}

# Get common state information
get_prop $UIF24_PROP CMN_UIF24                      # read only / set to actual
get_prop $UIF50_PROP CMN_UIF50                      # read only / set to actual
get_prop $DIF24_PROP CMN_DIF24                      # read only / set to actual
get_prop $DIF50_PROP CMN_DIF50                      # read only / set to actual
get_prop $WIF_PROP CMN_WIF                          # read only / set to actual
get_prop $BOOT_DONE_PROP BOOT_DONE                  # read only / set to actual

# Get information to determine debuggable state
get_prop $DBG_PROP DBG
get_prop $FOSFLAGS_VERBOSE_PROP FOSFLAGS_VERBOSE
get_prop $WIFI_VERBOSE_PROP WIFI_VERBOSE
ROOT=`$CAT /proc/idme/fos_flags`
ROOT=$((16#$ROOT >> 1))
ROOT=$(($ROOT % 2))

# Determine soft AP configuration (dev / test)
# - support older DISABLE_SAP_PROP (both tied together for backwards compatibility)
get_prop $DISABLE_SAP_PROP DISABLE_SAP              # configurable
get_prop $DISABLE_SAP_CTRL_PROP DISABLE_SAP_CTRL    # configurable
if [[ $DISABLE_SAP == '1' ]]; then
    CMN_DISABLE24='1'
    CMN_DISABLE50='1'
    dlog "NOTE: both 2.4G and 5G soft APs disabled"
else
    if [[ -n $DISABLE_SAP_CTRL ]] && [[ $(( $DISABLE_SAP_CTRL & 1 )) -gt 0 ]]; then
        CMN_DISABLE24='1'
        dlog "NOTE: 2.4G soft AP disabled"
    fi
    if [[ -n $DISABLE_SAP_CTRL ]] && [[ $(( $DISABLE_SAP_CTRL & 2 )) -gt 0 ]]; then
        CMN_DISABLE50='1'
        dlog "NOTE: 5G soft AP disabled"
    fi
fi
